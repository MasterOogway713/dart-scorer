<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Darts Scorer 501</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600;800&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Slate 900 */
            color: #e2e8f0;
            overflow-x: hidden;
        }

        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Dartboard specific styles */
        .dartboard-segment {
            stroke: #d1d5db; /* Gray 300 */
            stroke-width: 1px;
            transition: opacity 0.1s;
            cursor: pointer;
        }
        .dartboard-segment:hover {
            opacity: 0.8;
            stroke: #fff;
            stroke-width: 2px;
            z-index: 10;
        }
        .dartboard-text {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            fill: #fff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 24px;
        }
        
        .mic-active {
            animation: pulse-red 2s infinite;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        .active-player-card {
            border: 2px solid #3b82f6; /* Blue 500 */
            background-color: rgba(59, 130, 246, 0.1);
            transform: scale(1.02);
        }

        /* Hit animation */
        .hit-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #fbbf24 20%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: fadeOut 1s forwards;
            z-index: 50;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center">

    <!-- Header -->
    <header class="w-full bg-slate-800 p-4 shadow-lg mb-4">
        <div class="max-w-4xl mx-auto flex justify-between items-center">
            <h1 class="text-2xl font-extrabold text-blue-400 tracking-tight">üéØ Voice Darts 501</h1>
            <div class="flex gap-2">
                 <button onclick="manualEditScore()" class="text-xs bg-slate-700 hover:bg-slate-600 px-3 py-1 rounded text-yellow-400 transition border border-slate-600">Edit Score</button>
                 <button onclick="resetGame()" class="text-xs bg-slate-700 hover:bg-slate-600 px-3 py-1 rounded text-slate-300 transition border border-slate-600">Reset Game</button>
            </div>
        </div>
    </header>

    <main class="w-full max-w-5xl flex flex-col lg:flex-row gap-8 px-4 pb-8 flex-grow">
        
        <!-- Left Column: Scoreboard -->
        <div class="flex-1 flex flex-col gap-4">
            
            <!-- Player Scores -->
            <div class="grid grid-cols-2 gap-4">
                <!-- Player 1 -->
                <div id="p1-card" class="bg-slate-800 p-6 rounded-xl shadow-md transition-all duration-300 active-player-card relative overflow-hidden">
                    <div class="text-slate-400 text-sm font-bold uppercase tracking-wider mb-1">Player 1</div>
                    <div id="p1-score" class="text-6xl font-black font-mono text-white">501</div>
                    <div class="mt-4 flex gap-1 h-2">
                        <div id="p1-dart-1" class="flex-1 bg-slate-700 rounded-full transition-colors"></div>
                        <div id="p1-dart-2" class="flex-1 bg-slate-700 rounded-full transition-colors"></div>
                        <div id="p1-dart-3" class="flex-1 bg-slate-700 rounded-full transition-colors"></div>
                    </div>
                    <div id="p1-last" class="mt-2 text-xs text-slate-500 h-4">Last: -</div>
                </div>

                <!-- Player 2 -->
                <div id="p2-card" class="bg-slate-800 p-6 rounded-xl shadow-md transition-all duration-300 relative overflow-hidden">
                    <div class="text-slate-400 text-sm font-bold uppercase tracking-wider mb-1">Player 2</div>
                    <div id="p2-score" class="text-6xl font-black font-mono text-white">501</div>
                    <div class="mt-4 flex gap-1 h-2">
                        <div id="p2-dart-1" class="flex-1 bg-slate-700 rounded-full transition-colors"></div>
                        <div id="p2-dart-2" class="flex-1 bg-slate-700 rounded-full transition-colors"></div>
                        <div id="p2-dart-3" class="flex-1 bg-slate-700 rounded-full transition-colors"></div>
                    </div>
                    <div id="p2-last" class="mt-2 text-xs text-slate-500 h-4">Last: -</div>
                </div>
            </div>

            <!-- Current Turn Info -->
            <div class="bg-slate-800/50 p-4 rounded-lg border border-slate-700 flex justify-between items-center">
                <div>
                    <span class="text-slate-400 text-xs uppercase">Turn Total</span>
                    <div id="turn-total" class="text-3xl font-bold text-blue-400">0</div>
                </div>
                <div class="text-right">
                    <span class="text-slate-400 text-xs uppercase">Message</span>
                    <div id="status-msg" class="text-sm font-semibold text-white">Ready to throw</div>
                </div>
            </div>

            <!-- Voice Controls -->
            <div class="bg-slate-800 p-4 rounded-lg shadow-inner">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-slate-300">üéôÔ∏è Voice Mode</h3>
                    <div id="mic-status" class="text-xs text-slate-500 font-mono">OFF</div>
                </div>
                
                <!-- Mic Buttons Grid -->
                <div class="grid grid-cols-3 gap-2 mb-3">
                    <button onclick="setMicMode('single')" id="btn-single" class="py-2 px-1 rounded bg-slate-700 hover:bg-slate-600 text-slate-200 text-xs font-bold transition flex flex-col items-center gap-1 border border-slate-600">
                        <span>üé§</span>
                        <span>Single</span>
                    </button>
                    <button onclick="setMicMode('turn')" id="btn-turn" class="py-2 px-1 rounded bg-slate-700 hover:bg-slate-600 text-slate-200 text-xs font-bold transition flex flex-col items-center gap-1 border border-slate-600">
                        <span>üîÑ</span>
                        <span>Turn</span>
                    </button>
                    <button onclick="setMicMode('always')" id="btn-always" class="py-2 px-1 rounded bg-slate-700 hover:bg-slate-600 text-slate-200 text-xs font-bold transition flex flex-col items-center gap-1 border border-slate-600">
                        <span>‚ôæÔ∏è</span>
                        <span>Always</span>
                    </button>
                </div>

                <!-- Stop / Undo -->
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="stopListening()" class="py-2 rounded bg-red-900/50 hover:bg-red-900 text-red-200 text-xs font-bold transition border border-red-800/50">
                        Stop Mic
                    </button>
                    <button onclick="undoLastThrow()" class="py-2 rounded bg-amber-900/50 hover:bg-amber-900 text-amber-200 text-xs font-bold transition border border-amber-800/50 flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" /></svg>
                        Undo Last
                    </button>
                </div>

                <p class="text-[10px] text-slate-500 mt-3 text-center">
                    Say: "Triple 20", "Bullseye", "25", "Double 16"
                </p>
            </div>

            <!-- Log -->
            <div class="flex-grow bg-slate-900 rounded-lg p-2 overflow-y-auto max-h-48 border border-slate-800 font-mono text-xs text-slate-400" id="game-log">
                <div class="p-1 border-b border-slate-800">Game Started - 501</div>
            </div>
        </div>

        <!-- Right Column: Interactive Dartboard -->
        <div class="flex-1 flex justify-center items-start min-h-[400px] relative">
            <div id="board-container" class="relative w-full max-w-[500px] aspect-square">
                <!-- SVG Board Injected Here -->
                <svg id="dartboard" viewBox="-220 -220 440 440" class="w-full h-full drop-shadow-2xl">
                    <!-- Circles and Paths will be generated by JS -->
                </svg>
            </div>
        </div>

    </main>

    <!-- Winner Modal -->
    <div id="winner-modal" class="fixed inset-0 bg-black/80 hidden items-center justify-center z-50">
        <div class="bg-slate-800 p-8 rounded-2xl text-center max-w-sm mx-4 border border-blue-500 shadow-2xl">
            <div class="text-6xl mb-4">üèÜ</div>
            <h2 class="text-3xl font-bold text-white mb-2" id="winner-name">Player 1 Wins!</h2>
            <p class="text-slate-400 mb-6">Game Over</p>
            <button onclick="resetGame(); closeModal()" class="bg-blue-600 hover:bg-blue-500 text-white px-6 py-2 rounded-lg font-bold w-full">Play Again</button>
        </div>
    </div>

<script>
    // --- Configuration & Constants ---
    const SECTOR_ORDER = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];
    const COLORS = {
        black: "#1e293b", // Slate 800
        white: "#f1f5f9", // Slate 100
        red: "#ef4444",   // Red 500
        green: "#22c55e", // Green 500
        bullRed: "#dc2626",
        bullGreen: "#16a34a"
    };
    
    // Radii for dartboard rings (arbitrary units for SVG viewbox)
    const R_BULL_INNER = 6.35;
    const R_BULL_OUTER = 15.9;
    const R_TRIPLE_INNER = 99;
    const R_TRIPLE_OUTER = 107;
    const R_DOUBLE_INNER = 162;
    const R_DOUBLE_OUTER = 170;

    // --- State ---
    let gameState = {
        scores: [501, 501],
        currentPlayer: 0, // 0 for P1, 1 for P2
        dartsThrown: 0, // 0-3
        currentTurnScore: 0,
        startOfTurnScore: 501,
        history: [], // For Undo
        gameOver: false
    };

    let recognition = null;
    let isListening = false;
    let micMode = 'off'; // 'off', 'single', 'turn', 'always'

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        drawDartboard();
        updateUI();
        initSpeechRecognition();
    });

    // --- Dartboard Generation ---
    function drawDartboard() {
        const svg = document.getElementById('dartboard');
        const centerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        
        SECTOR_ORDER.forEach((number, i) => {
            const anglePerSlice = 360 / 20;
            const startAngle = -90 - (anglePerSlice / 2) + (i * anglePerSlice);
            const endAngle = startAngle + anglePerSlice;

            const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
            group.setAttribute("data-value", number);

            const isEven = i % 2 === 0;
            const singleColor = isEven ? COLORS.black : COLORS.white;
            const ringColor = isEven ? COLORS.red : COLORS.green;

            createArc(group, R_DOUBLE_INNER, R_DOUBLE_OUTER, startAngle, endAngle, ringColor, `Double ${number}`, number * 2);
            createArc(group, R_TRIPLE_OUTER, R_DOUBLE_INNER, startAngle, endAngle, singleColor, `Single ${number}`, number);
            createArc(group, R_TRIPLE_INNER, R_TRIPLE_OUTER, startAngle, endAngle, ringColor, `Triple ${number}`, number * 3);
            createArc(group, R_BULL_OUTER, R_TRIPLE_INNER, startAngle, endAngle, singleColor, `Single ${number}`, number);
            
            const textRadius = R_DOUBLE_OUTER + 20;
            const midAngle = (startAngle + endAngle) / 2;
            const rad = midAngle * Math.PI / 180;
            const tx = Math.cos(rad) * textRadius;
            const ty = Math.sin(rad) * textRadius;
            
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", tx);
            text.setAttribute("y", ty);
            text.setAttribute("class", "dartboard-text");
            text.textContent = number;
            
            svg.appendChild(group);
            svg.appendChild(text);
        });

        const outerBull = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        outerBull.setAttribute("r", R_BULL_OUTER);
        outerBull.setAttribute("fill", COLORS.bullGreen);
        outerBull.setAttribute("class", "dartboard-segment");
        outerBull.onclick = (e) => handleThrow(25, "Outer Bull", e);
        svg.appendChild(outerBull);

        const innerBull = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        innerBull.setAttribute("r", R_BULL_INNER);
        innerBull.setAttribute("fill", COLORS.bullRed);
        innerBull.setAttribute("class", "dartboard-segment");
        innerBull.onclick = (e) => handleThrow(50, "Bullseye", e);
        svg.appendChild(innerBull);
    }

    function createArc(group, innerR, outerR, startAngle, endAngle, color, label, points) {
        const startRad = (startAngle * Math.PI) / 180;
        const endRad = (endAngle * Math.PI) / 180;
        const x1 = Math.cos(startRad) * outerR;
        const y1 = Math.sin(startRad) * outerR;
        const x2 = Math.cos(endRad) * outerR;
        const y2 = Math.sin(endRad) * outerR;
        const x3 = Math.cos(endRad) * innerR;
        const y3 = Math.sin(endRad) * innerR;
        const x4 = Math.cos(startRad) * innerR;
        const y4 = Math.sin(startRad) * innerR;

        const pathStr = `M ${x1} ${y1} A ${outerR} ${outerR} 0 0 1 ${x2} ${y2} L ${x3} ${y3} A ${innerR} ${innerR} 0 0 0 ${x4} ${y4} Z`;
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", pathStr);
        path.setAttribute("fill", color);
        path.setAttribute("class", "dartboard-segment");
        path.onclick = (e) => handleThrow(points, label, e);
        group.appendChild(path);
    }

    // --- Game Logic ---

    function saveState() {
        // Deep clone the state for history
        const snapshot = JSON.parse(JSON.stringify({
            scores: gameState.scores,
            currentPlayer: gameState.currentPlayer,
            dartsThrown: gameState.dartsThrown,
            currentTurnScore: gameState.currentTurnScore,
            startOfTurnScore: gameState.startOfTurnScore,
            gameOver: gameState.gameOver
        }));
        gameState.history.push(snapshot);
        // Optional: limit history size
        if(gameState.history.length > 50) gameState.history.shift();
    }

    function undoLastThrow() {
        if (gameState.history.length === 0) {
            log("Nothing to undo.");
            return;
        }
        
        const prevState = gameState.history.pop();
        gameState.scores = prevState.scores;
        gameState.currentPlayer = prevState.currentPlayer;
        gameState.dartsThrown = prevState.dartsThrown;
        gameState.currentTurnScore = prevState.currentTurnScore;
        gameState.startOfTurnScore = prevState.startOfTurnScore;
        gameState.gameOver = prevState.gameOver;
        
        log("‚Ü©Ô∏è Undid last action");
        document.getElementById('status-msg').textContent = "Correction made";
        closeModal();
        updateUI();
    }

    function manualEditScore() {
        const player = gameState.currentPlayer;
        const currentScore = gameState.scores[player];
        const newScoreStr = prompt(`Edit Player ${player + 1} Score manually.\nCurrent: ${currentScore}`, currentScore);
        
        if (newScoreStr !== null) {
            const newScore = parseInt(newScoreStr);
            if (!isNaN(newScore) && newScore >= 0) {
                saveState();
                gameState.scores[player] = newScore;
                // If we manually edited, we might want to reset the turn state to avoid confusion
                // But generally users just want to fix the math.
                // Let's reset darts thrown if they edit the score manually to prevent weird "turn" math conflicts
                gameState.dartsThrown = 0;
                gameState.currentTurnScore = 0;
                gameState.startOfTurnScore = newScore;
                log(`‚úèÔ∏è Manual Edit: P${player+1} set to ${newScore}`);
                updateUI();
            }
        }
    }

    function handleThrow(points, label, event) {
        if (gameState.gameOver) return;

        saveState(); // Save before modifying

        if (event) {
            spawnHitMarker(event.clientX, event.clientY);
        }

        const player = gameState.currentPlayer;
        const currentScore = gameState.scores[player];
        let newScore = currentScore - points;

        gameState.dartsThrown++;
        gameState.currentTurnScore += points;
        
        // Bust Logic
        if (newScore < 0) {
            log(`Player ${player + 1} BUST! (${label})`);
            document.getElementById('status-msg').textContent = "BUST!";
            endTurn(true); 
            return;
        } else if (newScore === 0) {
            gameState.scores[player] = 0;
            log(`Player ${player + 1} HIT ${label} - CHECKOUT!`);
            winGame(player);
            updateUI();
            
            // Stop mic on game over
            if (isListening) stopListening();
            return;
        }

        gameState.scores[player] = newScore;
        log(`P${player+1}: ${label} (${points})`);
        
        updateUI();

        // Mic logic: Check if we need to stop listening based on mode
        if (micMode === 'turn' && gameState.dartsThrown >= 3) {
            // We wait a moment for the user to see the result, but typically we stop recognizing new inputs for this turn
            // However, the transition happens below in setTimeout. 
            // We'll let the endTurn function handle the state reset.
        }

        if (gameState.dartsThrown >= 3) {
            setTimeout(() => endTurn(false), 800);
        }
    }

    function endTurn(isBust) {
        const player = gameState.currentPlayer;
        
        if (isBust) {
            gameState.scores[player] = gameState.startOfTurnScore;
        }

        // Switch Player
        gameState.currentPlayer = player === 0 ? 1 : 0;
        gameState.dartsThrown = 0;
        gameState.currentTurnScore = 0;
        gameState.startOfTurnScore = gameState.scores[gameState.currentPlayer];
        
        document.getElementById('status-msg').textContent = `Player ${gameState.currentPlayer + 1}'s Turn`;
        updateUI();

        // If mode is 'turn', and turn just ended, we stop listening.
        if (micMode === 'turn') {
            stopListening();
        }
    }

    function winGame(playerId) {
        gameState.gameOver = true;
        document.getElementById('winner-name').textContent = `Player ${playerId + 1} Wins!`;
        document.getElementById('winner-modal').classList.replace('hidden', 'flex');
    }

    function resetGame() {
        if(isListening) stopListening();
        gameState = {
            scores: [501, 501],
            currentPlayer: 0,
            dartsThrown: 0,
            currentTurnScore: 0,
            startOfTurnScore: 501,
            history: [],
            gameOver: false
        };
        document.getElementById('game-log').innerHTML = '<div class="p-1 border-b border-slate-800">Game Started - 501</div>';
        document.getElementById('winner-modal').classList.replace('flex', 'hidden');
        closeModal();
        updateUI();
    }

    function closeModal() {
        document.getElementById('winner-modal').classList.add('hidden');
        document.getElementById('winner-modal').classList.remove('flex');
    }

    function updateUI() {
        document.getElementById('p1-score').textContent = gameState.scores[0];
        document.getElementById('p2-score').textContent = gameState.scores[1];
        
        const p1Card = document.getElementById('p1-card');
        const p2Card = document.getElementById('p2-card');
        
        if (gameState.currentPlayer === 0) {
            p1Card.classList.add('active-player-card', 'ring-2', 'ring-blue-500');
            p2Card.classList.remove('active-player-card', 'ring-2', 'ring-blue-500');
            p2Card.classList.add('opacity-50');
            p1Card.classList.remove('opacity-50');
        } else {
            p2Card.classList.add('active-player-card', 'ring-2', 'ring-blue-500');
            p1Card.classList.remove('active-player-card', 'ring-2', 'ring-blue-500');
            p1Card.classList.add('opacity-50');
            p2Card.classList.remove('opacity-50');
        }

        document.getElementById('turn-total').textContent = gameState.currentTurnScore;

        const p = gameState.currentPlayer + 1;
        const darts = gameState.dartsThrown;
        
        [1, 2].forEach(pl => {
            for(let i=1; i<=3; i++) document.getElementById(`p${pl}-dart-${i}`).classList.remove('bg-green-500', 'bg-slate-700');
        });

        for(let i=1; i<=3; i++) {
             const el = document.getElementById(`p${p}-dart-${i}`);
             el.classList.add('bg-slate-700');
             if (i <= darts) {
                 el.classList.remove('bg-slate-700');
                 el.classList.add('bg-green-500');
             }
        }
    }

    function log(msg) {
        const logEl = document.getElementById('game-log');
        const entry = document.createElement('div');
        entry.className = 'p-1 border-b border-slate-800 text-slate-300';
        entry.textContent = msg;
        logEl.prepend(entry);
    }

    function spawnHitMarker(x, y) {
        const marker = document.createElement('div');
        marker.className = 'hit-marker';
        marker.style.left = `${x}px`;
        marker.style.top = `${y}px`;
        document.body.appendChild(marker);
        setTimeout(() => marker.remove(), 1000);
    }

    // --- Voice Recognition ---

    function updateMicUI(listening, mode) {
        const status = document.getElementById('mic-status');
        const btnSingle = document.getElementById('btn-single');
        const btnTurn = document.getElementById('btn-turn');
        const btnAlways = document.getElementById('btn-always');

        // Reset Styles
        [btnSingle, btnTurn, btnAlways].forEach(btn => {
            btn.classList.remove('bg-red-600', 'mic-active');
            btn.classList.add('bg-slate-700');
        });

        if (listening) {
            status.textContent = `${mode.toUpperCase()} MODE ACTIVE`;
            status.className = "text-xs text-red-400 font-bold font-mono";
            
            if (mode === 'single') btnSingle.classList.add('bg-red-600', 'mic-active');
            if (mode === 'turn') btnTurn.classList.add('bg-red-600', 'mic-active');
            if (mode === 'always') btnAlways.classList.add('bg-red-600', 'mic-active');
        } else {
            status.textContent = "OFF";
            status.className = "text-xs text-slate-500 font-mono";
        }
    }

    function initSpeechRecognition() {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
            document.getElementById('mic-status').textContent = "Not Supported";
            return;
        }

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.continuous = false; 
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.onstart = () => {
            isListening = true;
            updateMicUI(true, micMode);
        };

        recognition.onend = () => {
            isListening = false;
            updateMicUI(false, micMode);
            
            // Auto-restart logic
            if (micMode === 'always') {
                if(!gameState.gameOver) startListening();
            } else if (micMode === 'turn') {
                // Keep listening if turn is not over
                if (!gameState.gameOver && gameState.dartsThrown < 3) {
                     startListening();
                } else {
                    // Turn is over or game over, stop fully
                    micMode = 'off';
                    updateMicUI(false, 'off');
                }
            } else if (micMode === 'single') {
                micMode = 'off';
                updateMicUI(false, 'off');
            }
        };

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            log(`üé§ Heard: "${transcript}"`);
            parseVoiceInput(transcript);
        };
        
        recognition.onerror = (event) => {
            if (event.error === 'aborted') return;
            if (event.error === 'not-allowed') {
                 log("Mic access denied.");
                 micMode = 'off';
            }
            // For always/turn mode, errors often mean silence timeout. We let onend handle restart.
        };
    }

    function setMicMode(mode) {
        if (!recognition) return;
        
        // If already in that mode, stop it
        if (isListening && micMode === mode) {
            stopListening();
            return;
        }

        micMode = mode;
        // Stop current before starting new mode to ensure clean state
        if (isListening) recognition.stop(); 
        
        // Wait slightly for stop to process before starting (logic handled in startListening call via UI button click usually, but here we force start)
        setTimeout(() => startListening(), 100);
    }

    function startListening() {
        if (isListening) return;
        try {
            recognition.start();
        } catch (e) {
            console.warn("Recog start error", e);
        }
    }

    function stopListening() {
        micMode = 'off';
        if (recognition) recognition.stop();
        isListening = false;
        updateMicUI(false, 'off');
    }

    function parseVoiceInput(text) {
        const lower = text.toLowerCase()
            .replace(/[.,]/g, ' ') 
            .replace(/\s+/g, ' ')  
            .trim();

        const parts = lower.split(' ');
        let i = 0;
        
        const parseNum = (word) => {
            if(!word) return null;
            if (word === 'one') return 1;
            if (word === 'two' || word === 'to' || word === 'too') return 2;
            if (word === 'three') return 3;
            if (word === 'four' || word === 'for') return 4;
            if (word === 'five') return 5;
            if (word === 'six') return 6;
            if (word === 'seven') return 7;
            if (word === 'eight') return 8;
            if (word === 'nine') return 9;
            if (word === 'ten') return 10;
            if (word === 'twenty') return 20;
            const num = parseInt(word);
            return isNaN(num) ? null : num;
        };

        while (i < parts.length) {
            // Check limits for Turn Mode inside the loop to prevent processing extra spoken words after bust/win
            if (micMode === 'turn' && (gameState.dartsThrown >= 3 || gameState.gameOver)) break;
            
            const word = parts[i];
            
            if (word.includes('bull')) {
                if (word === 'outer') {
                    handleThrow(25, "Outer Bull");
                    i+=2; 
                } else {
                    handleThrow(50, "Bullseye");
                    i++;
                }
                continue;
            }

            let multiplier = 1;
            let labelPrefix = "Single";
            let val = null;

            if (word === 'single') {
                multiplier = 1;
                i++;
            } else if (word === 'double') {
                multiplier = 2;
                labelPrefix = "Double";
                i++;
            } else if (word === 'triple' || word === 'treble') {
                multiplier = 3;
                labelPrefix = "Triple";
                i++;
            }

            if (i < parts.length) {
                if (parts[i] === 'twenty' && parts[i+1] === 'five') {
                    val = 25;
                    i+=2;
                } else {
                    val = parseNum(parts[i]);
                    i++;
                }
            }

            if (val !== null) {
                if (val === 25 && multiplier === 1) {
                    handleThrow(25, "Outer Bull");
                } 
                else if (val >= 0 && val <= 20) {
                    handleThrow(val * multiplier, `${labelPrefix} ${val}`);
                }
            } else {
                // Skip unrecognized word to keep loop moving
                // i++ is already handled if we consumed a multiplier but no number
                // if we didn't consume anything, force i++
                if (multiplier === 1 && val === null && !word.includes('bull')) {
                    i++;
                }
            }
        }
    }
</script>
</body>
</html>
